# YOLO ç›®æ ‡æ£€æµ‹å®éªŒæŒ‡æ ‡è¯¦è§£

## ç›®å½•
1. [æŒ‡æ ‡æ¦‚è¿°](#æŒ‡æ ‡æ¦‚è¿°)
2. [æ£€æµ‹æ€§èƒ½æŒ‡æ ‡](#æ£€æµ‹æ€§èƒ½æŒ‡æ ‡)
3. [æ¨¡å‹å¤æ‚åº¦æŒ‡æ ‡](#æ¨¡å‹å¤æ‚åº¦æŒ‡æ ‡)
4. [æ¨ç†æ€§èƒ½æŒ‡æ ‡](#æ¨ç†æ€§èƒ½æŒ‡æ ‡)
5. [è®­ç»ƒè¿‡ç¨‹æŒ‡æ ‡](#è®­ç»ƒè¿‡ç¨‹æŒ‡æ ‡)
6. [å®éªŒè®¾è®¡æŒ‡å—](#å®éªŒè®¾è®¡æŒ‡å—)
7. [æŒ‡æ ‡è®¡ç®—ä¸å¯è§†åŒ–](#æŒ‡æ ‡è®¡ç®—ä¸å¯è§†åŒ–)
8. [å¸¸è§é—®é¢˜ä¸æ³¨æ„äº‹é¡¹](#å¸¸è§é—®é¢˜ä¸æ³¨æ„äº‹é¡¹)

---

## æŒ‡æ ‡æ¦‚è¿°

### æŒ‡æ ‡åˆ†ç±»ä½“ç³»

```
YOLO å®éªŒæŒ‡æ ‡
â”œâ”€â”€ æ£€æµ‹æ€§èƒ½æŒ‡æ ‡ (Accuracy Metrics)
â”‚   â”œâ”€â”€ mAP (å¹³å‡ç²¾åº¦å‡å€¼)
â”‚   â”œâ”€â”€ Precision (ç²¾ç¡®ç‡)
â”‚   â”œâ”€â”€ Recall (å¬å›ç‡)
â”‚   â”œâ”€â”€ F1-Score (F1 åˆ†æ•°)
â”‚   â””â”€â”€ IoU (äº¤å¹¶æ¯”)
â”‚
â”œâ”€â”€ æ¨¡å‹å¤æ‚åº¦æŒ‡æ ‡ (Complexity Metrics)
â”‚   â”œâ”€â”€ Parameters (å‚æ•°é‡)
â”‚   â”œâ”€â”€ FLOPs/GFLOPs (è®¡ç®—é‡)
â”‚   â””â”€â”€ Model Size (æ¨¡å‹å¤§å°)
â”‚
â”œâ”€â”€ æ¨ç†æ€§èƒ½æŒ‡æ ‡ (Inference Metrics)
â”‚   â”œâ”€â”€ FPS (å¸§ç‡)
â”‚   â”œâ”€â”€ Latency (å»¶è¿Ÿ)
â”‚   â””â”€â”€ Throughput (ååé‡)
â”‚
â””â”€â”€ è®­ç»ƒè¿‡ç¨‹æŒ‡æ ‡ (Training Metrics)
    â”œâ”€â”€ Loss (æŸå¤±å‡½æ•°)
    â”œâ”€â”€ Learning Rate (å­¦ä¹ ç‡)
    â””â”€â”€ Convergence Speed (æ”¶æ•›é€Ÿåº¦)
```

---

## æ£€æµ‹æ€§èƒ½æŒ‡æ ‡

### 1. mAP (mean Average Precision)

**å®šä¹‰**: æ‰€æœ‰ç±»åˆ«çš„å¹³å‡ç²¾åº¦ (AP) çš„å‡å€¼ï¼Œæ˜¯ç›®æ ‡æ£€æµ‹æœ€é‡è¦çš„è¯„ä¼°æŒ‡æ ‡ã€‚

#### 1.1 mAP@0.5 (mAP50)

**å«ä¹‰**: IoU é˜ˆå€¼ä¸º 0.5 æ—¶çš„ mAP

**è®¡ç®—æ–¹æ³•**:
```python
# ä¼ªä»£ç 
for each_class:
    # 1. è®¡ç®—è¯¥ç±»åˆ«çš„ Precision-Recall æ›²çº¿
    precisions, recalls = compute_pr_curve(predictions, ground_truths, iou_threshold=0.5)

    # 2. è®¡ç®— AP (PR æ›²çº¿ä¸‹é¢ç§¯)
    AP = compute_area_under_curve(precisions, recalls)

# 3. è®¡ç®—æ‰€æœ‰ç±»åˆ«çš„å¹³å‡å€¼
mAP50 = mean(APs)
```

**é€‚ç”¨åœºæ™¯**:
- PASCAL VOC æ•°æ®é›†
- å¯¹å®šä½ç²¾åº¦è¦æ±‚ä¸é«˜çš„åœºæ™¯
- å¿«é€Ÿè¯„ä¼°æ¨¡å‹æ€§èƒ½

**å‚è€ƒå€¼** (COCO æ•°æ®é›†):
| æ¨¡å‹ | mAP@0.5 | è¯´æ˜ |
|------|---------|------|
| YOLOv8n | 52.8% | è½»é‡çº§æ¨¡å‹ |
| YOLOv8s | 61.5% | å°å‹æ¨¡å‹ |
| YOLOv8m | 67.2% | ä¸­å‹æ¨¡å‹ |
| YOLOv8l | 69.8% | å¤§å‹æ¨¡å‹ |
| YOLOv8x | 71.5% | è¶…å¤§å‹æ¨¡å‹ |

---

#### 1.2 mAP@0.5:0.95 (mAP)

**å«ä¹‰**: IoU é˜ˆå€¼ä» 0.5 åˆ° 0.95ï¼Œæ­¥é•¿ 0.05 çš„ mAP å¹³å‡å€¼

**è®¡ç®—æ–¹æ³•**:
```python
mAPs = []
for iou_threshold in [0.5, 0.55, 0.6, ..., 0.95]:
    mAP_at_threshold = compute_mAP(predictions, ground_truths, iou_threshold)
    mAPs.append(mAP_at_threshold)

mAP = mean(mAPs)  # 10 ä¸ªé˜ˆå€¼çš„å¹³å‡
```

**ç‰¹ç‚¹**:
- æ›´ä¸¥æ ¼çš„è¯„ä¼°æ ‡å‡†
- COCO æ•°æ®é›†çš„å®˜æ–¹æŒ‡æ ‡
- å¯¹å®šä½ç²¾åº¦è¦æ±‚æ›´é«˜

**å‚è€ƒå€¼** (COCO æ•°æ®é›†):
| æ¨¡å‹ | mAP@0.5:0.95 | å‚æ•°é‡ | GFLOPs |
|------|--------------|--------|--------|
| YOLOv8n | 37.3% | 3.2M | 8.7 |
| YOLOv8s | 44.9% | 11.2M | 28.6 |
| YOLOv8m | 50.2% | 25.9M | 78.9 |
| YOLOv8l | 52.9% | 43.7M | 165.2 |
| YOLOv8x | 53.9% | 68.2M | 257.8 |

---

#### 1.3 AP åˆ†ç±»æŒ‡æ ‡

**AP_small**: å°ç›®æ ‡ (é¢ç§¯ < 32Â²) çš„å¹³å‡ç²¾åº¦
**AP_medium**: ä¸­ç­‰ç›®æ ‡ (32Â² < é¢ç§¯ < 96Â²) çš„å¹³å‡ç²¾åº¦
**AP_large**: å¤§ç›®æ ‡ (é¢ç§¯ > 96Â²) çš„å¹³å‡ç²¾åº¦

**ä½¿ç”¨åœºæ™¯**:
```python
# åˆ†ææ¨¡å‹å¯¹ä¸åŒå°ºåº¦ç›®æ ‡çš„æ£€æµ‹èƒ½åŠ›
results = model.val(data='coco.yaml')

print(f"AP_small: {results.maps['small']:.3f}")   # å°ç›®æ ‡
print(f"AP_medium: {results.maps['medium']:.3f}") # ä¸­ç›®æ ‡
print(f"AP_large: {results.maps['large']:.3f}")   # å¤§ç›®æ ‡
```

**å…¸å‹é—®é¢˜åˆ†æ**:
- AP_small ä½ï¼šè€ƒè™‘å¢åŠ å°ç›®æ ‡æ£€æµ‹å¤´ã€ä½¿ç”¨ç‰¹å¾é‡‘å­—å¡”
- AP_large ä½ï¼šæ£€æŸ¥æ„Ÿå—é‡æ˜¯å¦è¶³å¤Ÿå¤§
- ä¸åŒå°ºåº¦å·®å¼‚å¤§ï¼šè€ƒè™‘å¤šå°ºåº¦è®­ç»ƒ

---

### 2. Precision (ç²¾ç¡®ç‡)

**å®šä¹‰**: é¢„æµ‹ä¸ºæ­£ä¾‹ä¸­çœŸæ­£ä¸ºæ­£ä¾‹çš„æ¯”ä¾‹

**å…¬å¼**:
```
Precision = TP / (TP + FP)
```

**å«ä¹‰**:
- TP (True Positive): æ­£ç¡®æ£€æµ‹åˆ°çš„ç›®æ ‡
- FP (False Positive): è¯¯æ£€æµ‹çš„èƒŒæ™¯
- è¡¡é‡æ¨¡å‹çš„"å‡†ç¡®æ€§"

**å®é™…æ„ä¹‰**:
- é«˜ Precisionï¼šæ¨¡å‹é¢„æµ‹çš„ç»“æœå¯ä¿¡åº¦é«˜ï¼Œè¯¯æŠ¥å°‘
- ä½ Precisionï¼šæ¨¡å‹äº§ç”Ÿå¾ˆå¤šè¯¯æ£€æµ‹ï¼ˆå‡é˜³æ€§ï¼‰

**åº”ç”¨åœºæ™¯**:
- è¯¯æ£€ä»£ä»·é«˜çš„åœºæ™¯ï¼ˆå¦‚åŒ»ç–—è¯Šæ–­ï¼‰
- éœ€è¦é«˜ç½®ä¿¡åº¦çš„åº”ç”¨

**è®¡ç®—ç¤ºä¾‹**:
```python
from ultralytics import YOLO

model = YOLO('yolov8n.pt')
results = model.val(data='coco.yaml')

# è·å–ç²¾ç¡®ç‡
precision = results.box.p  # æ¯ä¸ªç±»åˆ«çš„ precision
mean_precision = results.box.mp  # å¹³å‡ precision

print(f"Mean Precision: {mean_precision:.3f}")
```

---

### 3. Recall (å¬å›ç‡)

**å®šä¹‰**: æ‰€æœ‰æ­£ä¾‹ä¸­è¢«æ­£ç¡®é¢„æµ‹çš„æ¯”ä¾‹

**å…¬å¼**:
```
Recall = TP / (TP + FN)
```

**å«ä¹‰**:
- FN (False Negative): æ¼æ£€æµ‹çš„ç›®æ ‡
- è¡¡é‡æ¨¡å‹çš„"å®Œæ•´æ€§"

**å®é™…æ„ä¹‰**:
- é«˜ Recallï¼šæ¨¡å‹èƒ½æ‰¾åˆ°å¤§éƒ¨åˆ†ç›®æ ‡ï¼Œæ¼æ£€å°‘
- ä½ Recallï¼šæ¨¡å‹æ¼æ£€å¾ˆå¤šç›®æ ‡

**åº”ç”¨åœºæ™¯**:
- æ¼æ£€ä»£ä»·é«˜çš„åœºæ™¯ï¼ˆå¦‚å®‰å…¨ç›‘æ§ï¼‰
- éœ€è¦æ‰¾åˆ°æ‰€æœ‰ç›®æ ‡çš„åº”ç”¨

**è®¡ç®—ç¤ºä¾‹**:
```python
recall = results.box.r  # æ¯ä¸ªç±»åˆ«çš„ recall
mean_recall = results.box.mr  # å¹³å‡ recall

print(f"Mean Recall: {mean_recall:.3f}")
```

---

### 4. F1-Score

**å®šä¹‰**: Precision å’Œ Recall çš„è°ƒå’Œå¹³å‡æ•°

**å…¬å¼**:
```
F1 = 2 Ã— (Precision Ã— Recall) / (Precision + Recall)
```

**ç‰¹ç‚¹**:
- ç»¼åˆè€ƒè™‘ç²¾ç¡®ç‡å’Œå¬å›ç‡
- å¹³è¡¡ä¸¤è€…çš„é‡è¦æ€§
- å–å€¼èŒƒå›´ [0, 1]ï¼Œè¶Šå¤§è¶Šå¥½

**ä½¿ç”¨åœºæ™¯**:
- éœ€è¦å¹³è¡¡ç²¾ç¡®ç‡å’Œå¬å›ç‡
- ç±»åˆ«ä¸å¹³è¡¡æ—¶çš„è¯„ä¼°

**è®¡ç®—ç¤ºä¾‹**:
```python
f1_score = 2 * (precision * recall) / (precision + recall)
print(f"F1-Score: {f1_score:.3f}")
```

---

### 5. IoU (Intersection over Union)

**å®šä¹‰**: é¢„æµ‹æ¡†ä¸çœŸå®æ¡†çš„äº¤é›†ä¸å¹¶é›†çš„æ¯”å€¼

**å…¬å¼**:
```
IoU = Area(Prediction âˆ© Ground Truth) / Area(Prediction âˆª Ground Truth)
```

**å¯è§†åŒ–**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             â”‚  Prediction Box
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”
â”‚    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚    â”‚  â–ˆâ–ˆâ–ˆâ–ˆ = Intersection
â”‚    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚    â”‚
â””â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
     â”‚             â”‚  Ground Truth Box
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å–å€¼èŒƒå›´**: [0, 1]
- IoU = 0: å®Œå…¨ä¸é‡å 
- IoU = 1: å®Œå…¨é‡å 
- IoU > 0.5: é€šå¸¸è®¤ä¸ºæ£€æµ‹æ­£ç¡®

**åº”ç”¨**:
- åˆ¤æ–­æ£€æµ‹æ˜¯å¦æ­£ç¡® (True Positive)
- è¯„ä¼°å®šä½ç²¾åº¦
- NMS (éæå¤§å€¼æŠ‘åˆ¶) çš„é˜ˆå€¼

**è®¡ç®—ç¤ºä¾‹**:
```python
def calculate_iou(box1, box2):
    """
    è®¡ç®—ä¸¤ä¸ªè¾¹ç•Œæ¡†çš„ IoU

    Args:
        box1, box2: [x1, y1, x2, y2] æ ¼å¼çš„è¾¹ç•Œæ¡†

    Returns:
        iou: IoU å€¼
    """
    # è®¡ç®—äº¤é›†åæ ‡
    x1 = max(box1[0], box2[0])
    y1 = max(box1[1], box2[1])
    x2 = min(box1[2], box2[2])
    y2 = min(box1[3], box2[3])

    # è®¡ç®—äº¤é›†é¢ç§¯
    intersection = max(0, x2 - x1) * max(0, y2 - y1)

    # è®¡ç®—å¹¶é›†é¢ç§¯
    area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])
    area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])
    union = area1 + area2 - intersection

    # è®¡ç®— IoU
    iou = intersection / union if union > 0 else 0
    return iou
```

---

### 6. Confusion Matrix (æ··æ·†çŸ©é˜µ)

**å®šä¹‰**: æ˜¾ç¤ºå®é™…ç±»åˆ«ä¸é¢„æµ‹ç±»åˆ«å¯¹åº”å…³ç³»çš„çŸ©é˜µ

**ç»“æ„**:
```
                 Predicted
                 Positive  Negative
Actual Positive    TP        FN
       Negative    FP        TN
```

**å„æŒ‡æ ‡å«ä¹‰**:
- **TP (True Positive)**: æ­£ç¡®æ£€æµ‹åˆ°çš„ç›®æ ‡æ•°
- **FP (False Positive)**: è¯¯æ£€æµ‹æ•°ï¼ˆå°†èƒŒæ™¯è¯¯è®¤ä¸ºç›®æ ‡ï¼‰
- **FN (False Negative)**: æ¼æ£€æµ‹æ•°ï¼ˆæœªæ£€æµ‹åˆ°çš„ç›®æ ‡ï¼‰
- **TN (True Negative)**: æ­£ç¡®è¯†åˆ«çš„èƒŒæ™¯æ•°ï¼ˆç›®æ ‡æ£€æµ‹ä¸­è¾ƒå°‘ä½¿ç”¨ï¼‰

**å¯è§†åŒ–ç¤ºä¾‹**:
```python
from ultralytics import YOLO

model = YOLO('yolov8n.pt')
results = model.val(data='coco.yaml')

# æ··æ·†çŸ©é˜µä¼šè‡ªåŠ¨ä¿å­˜åˆ° runs/detect/val/confusion_matrix.png
```

---

## æ¨¡å‹å¤æ‚åº¦æŒ‡æ ‡

### 1. Parameters (å‚æ•°é‡)

**å®šä¹‰**: æ¨¡å‹ä¸­æ‰€æœ‰å¯å­¦ä¹ å‚æ•°çš„æ€»æ•°

**è®¡ç®—æ–¹æ³•**:
```python
def count_parameters(model):
    """è®¡ç®—æ¨¡å‹å‚æ•°é‡"""
    return sum(p.numel() for p in model.parameters())

# ä½¿ç”¨ Ultralytics
from ultralytics import YOLO
model = YOLO('yolov8n.pt')
model.info()  # æ˜¾ç¤ºå‚æ•°é‡
```

**å•ä½**:
- K (åƒ): 10Â³
- M (ç™¾ä¸‡): 10â¶
- B (åäº¿): 10â¹

**å…¸å‹å€¼**:
| æ¨¡å‹ | å‚æ•°é‡ | è¯´æ˜ |
|------|--------|------|
| YOLOv8n | 3.2M | è½»é‡çº§ï¼Œé€‚åˆè¾¹ç¼˜è®¾å¤‡ |
| YOLOv8s | 11.2M | å°å‹ï¼Œå¹³è¡¡æ€§èƒ½å’Œé€Ÿåº¦ |
| YOLOv8m | 25.9M | ä¸­å‹ï¼Œå¸¸ç”¨äºæœåŠ¡å™¨ |
| YOLOv8l | 43.7M | å¤§å‹ï¼Œé«˜ç²¾åº¦åº”ç”¨ |
| YOLOv8x | 68.2M | è¶…å¤§å‹ï¼Œæœ€é«˜ç²¾åº¦ |

**å®éªŒæ„ä¹‰**:
- å‚æ•°é‡è¶Šå°‘ï¼Œæ¨¡å‹è¶Šè½»é‡
- å½±å“æ¨¡å‹å¤§å°å’Œå†…å­˜å ç”¨
- éƒ¨ç½²åˆ°è¾¹ç¼˜è®¾å¤‡æ—¶çš„å…³é”®æŒ‡æ ‡

---

### 2. FLOPs / GFLOPs (æµ®ç‚¹è¿ç®—æ¬¡æ•°)

**å®šä¹‰**: æ¨¡å‹å‰å‘ä¼ æ’­ä¸€æ¬¡æ‰€éœ€çš„æµ®ç‚¹è¿ç®—æ¬¡æ•°

**å•ä½**:
- FLOPs: Floating Point Operations (æµ®ç‚¹è¿ç®—)
- GFLOPs: Giga FLOPs (10â¹ æ¬¡æµ®ç‚¹è¿ç®—)

**è®¡ç®—æ–¹æ³•**:
```python
from ultralytics.utils.torch_utils import model_info

# æ–¹æ³• 1: ä½¿ç”¨ Ultralytics
model = YOLO('yolov8n.pt')
model.info(verbose=True)

# æ–¹æ³• 2: æ‰‹åŠ¨è®¡ç®—
from thop import profile
import torch

model = YOLO('yolov8n.pt').model
input = torch.randn(1, 3, 640, 640)
flops, params = profile(model, inputs=(input,))
print(f'FLOPs: {flops / 1e9:.2f}G')
```

**å…¸å‹å€¼**:
| æ¨¡å‹ | GFLOPs (640Ã—640) | è¯´æ˜ |
|------|------------------|------|
| YOLOv8n | 8.7 | æœ€å¿« |
| YOLOv8s | 28.6 | å¿«é€Ÿ |
| YOLOv8m | 78.9 | ä¸­ç­‰ |
| YOLOv8l | 165.2 | è¾ƒæ…¢ |
| YOLOv8x | 257.8 | æœ€æ…¢ |

**å®éªŒæ„ä¹‰**:
- åæ˜ æ¨¡å‹è®¡ç®—å¤æ‚åº¦
- å½±å“æ¨ç†é€Ÿåº¦
- ä¸è¾“å…¥åˆ†è¾¨ç‡æˆæ­£æ¯”

**è®¡ç®—é‡ä¸åˆ†è¾¨ç‡å…³ç³»**:
```python
# ä¸åŒåˆ†è¾¨ç‡çš„è®¡ç®—é‡
Resolution    FLOPs (YOLOv8n)
320Ã—320       2.2 GFLOPs  (Ã·4)
640Ã—640       8.7 GFLOPs  (Ã—1)
1280Ã—1280     34.8 GFLOPs (Ã—4)
```

---

### 3. Model Size (æ¨¡å‹å¤§å°)

**å®šä¹‰**: æ¨¡å‹æ–‡ä»¶çš„å­˜å‚¨å¤§å°

**è®¡ç®—æ–¹æ³•**:
```python
import os

model_path = 'yolov8n.pt'
model_size_mb = os.path.getsize(model_path) / (1024 * 1024)
print(f'Model Size: {model_size_mb:.2f} MB')
```

**å½±å“å› ç´ **:
- å‚æ•°é‡ (ä¸»è¦å› ç´ )
- å‚æ•°æ•°æ®ç±»å‹ (FP32, FP16, INT8)
- æ¨¡å‹å‹ç¼©æŠ€æœ¯

**å…¸å‹å€¼**:
| æ¨¡å‹ | FP32 å¤§å° | FP16 å¤§å° | INT8 å¤§å° |
|------|-----------|-----------|-----------|
| YOLOv8n | 6.2 MB | 3.1 MB | 1.6 MB |
| YOLOv8s | 22.5 MB | 11.2 MB | 5.6 MB |
| YOLOv8m | 52.0 MB | 26.0 MB | 13.0 MB |
| YOLOv8l | 87.7 MB | 43.8 MB | 21.9 MB |
| YOLOv8x | 136.7 MB | 68.3 MB | 34.2 MB |

**å®éªŒæ„ä¹‰**:
- å­˜å‚¨ç©ºé—´éœ€æ±‚
- ç½‘ç»œä¼ è¾“æ—¶é—´
- æ¨¡å‹åŠ è½½é€Ÿåº¦

---

### 4. Memory Usage (å†…å­˜å ç”¨)

**å®šä¹‰**: æ¨¡å‹è¿è¡Œæ—¶çš„å†…å­˜æ¶ˆè€—

**ç»„æˆéƒ¨åˆ†**:
1. **æ¨¡å‹å‚æ•°**: å‚æ•°é‡ Ã— æ•°æ®ç±»å‹å¤§å°
2. **ä¸­é—´æ¿€æ´»**: å–å†³äºæ‰¹æ¬¡å¤§å°å’Œè¾“å…¥åˆ†è¾¨ç‡
3. **æ¢¯åº¦**: è®­ç»ƒæ—¶éœ€è¦ï¼Œçº¦ç­‰äºå‚æ•°é‡

**è®¡ç®—å…¬å¼**:
```python
# æ¨ç†æ—¶å†…å­˜ (GB)
memory_inference = (params_count Ã— 4) / 1e9  # FP32

# è®­ç»ƒæ—¶å†…å­˜ (GB)
memory_training = (params_count Ã— 4 Ã— 3) / 1e9  # å‚æ•° + æ¢¯åº¦ + ä¼˜åŒ–å™¨çŠ¶æ€
```

**å®æµ‹ç¤ºä¾‹**:
```python
import torch
from ultralytics import YOLO

model = YOLO('yolov8n.pt')

# GPU å†…å­˜ç›‘æ§
if torch.cuda.is_available():
    torch.cuda.empty_cache()
    torch.cuda.reset_peak_memory_stats()

    # æ¨ç†
    results = model.predict('image.jpg')

    # è·å–å†…å­˜ä½¿ç”¨
    memory_mb = torch.cuda.max_memory_allocated() / 1024**2
    print(f'Peak GPU Memory: {memory_mb:.2f} MB')
```

---

## æ¨ç†æ€§èƒ½æŒ‡æ ‡

### 1. FPS (Frames Per Second)

**å®šä¹‰**: æ¯ç§’å¤„ç†çš„å›¾åƒå¸§æ•°

**è®¡ç®—æ–¹æ³•**:
```python
import time
import torch
from ultralytics import YOLO

model = YOLO('yolov8n.pt')

# é¢„çƒ­
for _ in range(10):
    model.predict('image.jpg', verbose=False)

# æµ‹è¯•
num_images = 100
start_time = time.time()

for _ in range(num_images):
    results = model.predict('image.jpg', verbose=False)

end_time = time.time()
fps = num_images / (end_time - start_time)
print(f'FPS: {fps:.2f}')
```

**å½±å“å› ç´ **:
- ç¡¬ä»¶ (GPU/CPU)
- æ‰¹æ¬¡å¤§å°
- è¾“å…¥åˆ†è¾¨ç‡
- æ¨¡å‹å¤§å°

**å…¸å‹å€¼** (NVIDIA V100, Batch=1, 640Ã—640):
| æ¨¡å‹ | FPS (GPU) | FPS (CPU) |
|------|-----------|-----------|
| YOLOv8n | 238 | 15 |
| YOLOv8s | 156 | 8 |
| YOLOv8m | 83 | 4 |
| YOLOv8l | 52 | 2 |
| YOLOv8x | 35 | 1 |

**å®éªŒæ„ä¹‰**:
- å®æ—¶æ€§è¯„ä¼°
- FPS > 30: å®æ—¶æ£€æµ‹
- FPS > 60: é«˜é€Ÿåœºæ™¯

---

### 2. Latency (å»¶è¿Ÿ)

**å®šä¹‰**: å¤„ç†å•å¼ å›¾åƒæ‰€éœ€çš„æ—¶é—´

**è®¡ç®—æ–¹æ³•**:
```python
latencies = []

for _ in range(100):
    start = time.time()
    results = model.predict('image.jpg', verbose=False)
    latency = (time.time() - start) * 1000  # è½¬æ¢ä¸ºæ¯«ç§’
    latencies.append(latency)

# ç»Ÿè®¡
import numpy as np
mean_latency = np.mean(latencies)
p50_latency = np.percentile(latencies, 50)
p95_latency = np.percentile(latencies, 95)
p99_latency = np.percentile(latencies, 99)

print(f'Mean Latency: {mean_latency:.2f} ms')
print(f'P50 Latency: {p50_latency:.2f} ms')
print(f'P95 Latency: {p95_latency:.2f} ms')
print(f'P99 Latency: {p99_latency:.2f} ms')
```

**å…³ç³»**:
```
Latency (ms) = 1000 / FPS
```

**å…³é”®æŒ‡æ ‡**:
- **Mean Latency**: å¹³å‡å»¶è¿Ÿ
- **P50**: 50% çš„è¯·æ±‚å»¶è¿Ÿä½äºæ­¤å€¼
- **P95**: 95% çš„è¯·æ±‚å»¶è¿Ÿä½äºæ­¤å€¼ï¼ˆæœåŠ¡è´¨é‡æŒ‡æ ‡ï¼‰
- **P99**: 99% çš„è¯·æ±‚å»¶è¿Ÿä½äºæ­¤å€¼ï¼ˆæœ€åæƒ…å†µï¼‰

**å®éªŒæ„ä¹‰**:
- ç”¨æˆ·ä½“éªŒè¯„ä¼°
- å®æ—¶åº”ç”¨çš„å…³é”®æŒ‡æ ‡
- < 100ms: è‰¯å¥½çš„å®æ—¶ä½“éªŒ

---

### 3. Throughput (ååé‡)

**å®šä¹‰**: å•ä½æ—¶é—´å†…å¤„ç†çš„å›¾åƒæ•°é‡

**è®¡ç®—æ–¹æ³•**:
```python
# æ‰¹å¤„ç†ååé‡æµ‹è¯•
batch_sizes = [1, 4, 8, 16, 32]

for batch_size in batch_sizes:
    images = [torch.randn(3, 640, 640) for _ in range(batch_size)]

    start = time.time()
    for _ in range(10):  # é‡å¤ 10 æ¬¡
        results = model.predict(images, verbose=False)
    elapsed = time.time() - start

    throughput = (batch_size * 10) / elapsed
    print(f'Batch {batch_size}: {throughput:.2f} images/sec')
```

**ä¸ FPS çš„åŒºåˆ«**:
- FPS: å•å¼ å›¾åƒçš„å¤„ç†é€Ÿåº¦
- Throughput: è€ƒè™‘æ‰¹å¤„ç†çš„æ€»å¤„ç†èƒ½åŠ›

**å½±å“å› ç´ **:
- æ‰¹æ¬¡å¤§å°
- GPU åˆ©ç”¨ç‡
- å†…å­˜å¸¦å®½

---

### 4. è®¾å¤‡æ€§èƒ½å¯¹æ¯”

**GPU å¯¹æ¯”** (YOLOv8n, 640Ã—640, Batch=1):

| GPU | FPS | Latency | ä»·æ ¼ | æ€§ä»·æ¯” |
|-----|-----|---------|------|--------|
| RTX 4090 | 312 | 3.2ms | $$$$$ | â­â­â­â­ |
| RTX 4080 | 278 | 3.6ms | $$$$ | â­â­â­â­â­ |
| RTX 3090 | 245 | 4.1ms | $$$ | â­â­â­â­ |
| RTX 3080 | 218 | 4.6ms | $$$ | â­â­â­â­ |
| V100 | 238 | 4.2ms | $$$$ | â­â­â­ |
| T4 | 145 | 6.9ms | $$ | â­â­â­â­ |
| Jetson Orin | 89 | 11.2ms | $$ | â­â­â­â­â­ |
| Jetson Xavier | 52 | 19.2ms | $ | â­â­â­â­ |

---

## è®­ç»ƒè¿‡ç¨‹æŒ‡æ ‡

### 1. Loss (æŸå¤±å‡½æ•°)

**ç»„æˆéƒ¨åˆ†** (YOLOv8):
```
Total Loss = Î»â‚ Ã— Box Loss + Î»â‚‚ Ã— Class Loss + Î»â‚ƒ Ã— DFL Loss
```

#### 1.1 Box Loss (è¾¹ç•Œæ¡†æŸå¤±)

**ä½œç”¨**: è¡¡é‡é¢„æµ‹æ¡†ä¸çœŸå®æ¡†çš„å®šä½è¯¯å·®

**è®¡ç®—æ–¹æ³•** (CIoU Loss):
```python
def ciou_loss(pred_box, gt_box):
    """
    Complete IoU Loss

    CIoU = IoU - ÏÂ²(b, b^gt) / cÂ² - Î±v
    å…¶ä¸­:
    - Ï: é¢„æµ‹æ¡†å’ŒçœŸå®æ¡†ä¸­å¿ƒç‚¹è·ç¦»
    - c: æœ€å°å¤–æ¥æ¡†å¯¹è§’çº¿è·ç¦»
    - v: å®½é«˜æ¯”ä¸€è‡´æ€§
    - Î±: æƒé‡å‚æ•°
    """
    iou = calculate_iou(pred_box, gt_box)

    # ä¸­å¿ƒç‚¹è·ç¦»
    center_distance = ((pred_box[:2] - gt_box[:2]) ** 2).sum()

    # æœ€å°å¤–æ¥æ¡†å¯¹è§’çº¿
    diagonal = ((pred_box[2:] - gt_box[:2]) ** 2).sum()

    # å®½é«˜æ¯”ä¸€è‡´æ€§
    v = (4 / (math.pi ** 2)) * ((torch.atan(gt_box[2] / gt_box[3]) -
                                  torch.atan(pred_box[2] / pred_box[3])) ** 2)

    alpha = v / (1 - iou + v)

    ciou = iou - center_distance / diagonal - alpha * v
    loss = 1 - ciou

    return loss
```

**ç‰¹ç‚¹**:
- è€ƒè™‘ IoUã€ä¸­å¿ƒç‚¹è·ç¦»ã€å®½é«˜æ¯”
- æ”¶æ•›æ›´å¿«ï¼Œå®šä½æ›´å‡†ç¡®

**ç›‘æ§æ–¹æ³•**:
```python
# è®­ç»ƒæ—¶æŸ¥çœ‹
# runs/detect/train/results.csv
# åˆ—: train/box_loss, val/box_loss
```

---

#### 1.2 Class Loss (åˆ†ç±»æŸå¤±)

**ä½œç”¨**: è¡¡é‡ç±»åˆ«é¢„æµ‹çš„å‡†ç¡®æ€§

**è®¡ç®—æ–¹æ³•** (Binary Cross Entropy):
```python
def bce_loss(pred_cls, gt_cls):
    """
    äºŒå…ƒäº¤å‰ç†µæŸå¤±

    BCE = -[y log(p) + (1-y) log(1-p)]
    """
    loss = -(gt_cls * torch.log(pred_cls) +
             (1 - gt_cls) * torch.log(1 - pred_cls))
    return loss.mean()
```

**ç‰¹ç‚¹**:
- å¤šæ ‡ç­¾åˆ†ç±»
- æ¯ä¸ªç±»åˆ«ç‹¬ç«‹è®¡ç®—

---

#### 1.3 DFL Loss (Distribution Focal Loss)

**ä½œç”¨**: ä¼˜åŒ–è¾¹ç•Œæ¡†å›å½’çš„åˆ†å¸ƒè¡¨ç¤º

**åŸç†**:
- å°†è¿ç»­çš„è¾¹ç•Œæ¡†åæ ‡è½¬æ¢ä¸ºç¦»æ•£åˆ†å¸ƒ
- ä½¿ç”¨ Softmax + åŠ æƒæ±‚å’Œå¾—åˆ°æœ€ç»ˆåæ ‡

**è®¡ç®—æ–¹æ³•**:
```python
def dfl_loss(pred_dist, target):
    """
    Distribution Focal Loss

    é¢„æµ‹åˆ†å¸ƒåº”è¯¥åœ¨ç›®æ ‡å€¼é™„è¿‘é›†ä¸­
    """
    target_left = target.floor().long()
    target_right = target_left + 1
    weight_left = target_right - target
    weight_right = target - target_left

    loss = -(weight_left * torch.log(pred_dist[target_left]) +
             weight_right * torch.log(pred_dist[target_right]))

    return loss.mean()
```

---

### 2. æŸå¤±å‡½æ•°å¯è§†åŒ–ä¸åˆ†æ

**è®­ç»ƒæ›²çº¿ç¤ºä¾‹**:
```python
import matplotlib.pyplot as plt
import pandas as pd

# è¯»å–è®­ç»ƒç»“æœ
results = pd.read_csv('runs/detect/train/results.csv')

# ç»˜åˆ¶æŸå¤±æ›²çº¿
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# Box Loss
axes[0, 0].plot(results['epoch'], results['train/box_loss'], label='Train')
axes[0, 0].plot(results['epoch'], results['val/box_loss'], label='Val')
axes[0, 0].set_title('Box Loss')
axes[0, 0].set_xlabel('Epoch')
axes[0, 0].legend()

# Class Loss
axes[0, 1].plot(results['epoch'], results['train/cls_loss'], label='Train')
axes[0, 1].plot(results['epoch'], results['val/cls_loss'], label='Val')
axes[0, 1].set_title('Class Loss')
axes[0, 1].set_xlabel('Epoch')
axes[0, 1].legend()

# DFL Loss
axes[1, 0].plot(results['epoch'], results['train/dfl_loss'], label='Train')
axes[1, 0].plot(results['epoch'], results['val/dfl_loss'], label='Val')
axes[1, 0].set_title('DFL Loss')
axes[1, 0].set_xlabel('Epoch')
axes[1, 0].legend()

# Total Loss
total_train = (results['train/box_loss'] +
               results['train/cls_loss'] +
               results['train/dfl_loss'])
total_val = (results['val/box_loss'] +
             results['val/cls_loss'] +
             results['val/dfl_loss'])
axes[1, 1].plot(results['epoch'], total_train, label='Train')
axes[1, 1].plot(results['epoch'], total_val, label='Val')
axes[1, 1].set_title('Total Loss')
axes[1, 1].set_xlabel('Epoch')
axes[1, 1].legend()

plt.tight_layout()
plt.savefig('loss_curves.png')
```

---

### 3. Learning Rate (å­¦ä¹ ç‡)

**å®šä¹‰**: æ§åˆ¶å‚æ•°æ›´æ–°æ­¥é•¿çš„è¶…å‚æ•°

**å­¦ä¹ ç‡è°ƒåº¦ç­–ç•¥**:

#### 3.1 Cosine Annealing (ä½™å¼¦é€€ç«)
```python
lr = lr_initial Ã— (1 + cos(Ï€ Ã— epoch / total_epochs)) / 2
```

**ç‰¹ç‚¹**:
- å¹³æ»‘ä¸‹é™
- YOLOv8 é»˜è®¤ç­–ç•¥

**å¯è§†åŒ–**:
```python
import numpy as np
import matplotlib.pyplot as plt

epochs = np.arange(0, 300)
lr_initial = 0.01
lr_final = 0.0001

# ä½™å¼¦é€€ç«
lr = lr_final + (lr_initial - lr_final) * (1 + np.cos(np.pi * epochs / 300)) / 2

plt.plot(epochs, lr)
plt.xlabel('Epoch')
plt.ylabel('Learning Rate')
plt.title('Cosine Annealing LR Schedule')
plt.grid(True)
plt.savefig('lr_schedule.png')
```

#### 3.2 Linear (çº¿æ€§è¡°å‡)
```python
lr = lr_initial Ã— (1 - epoch / total_epochs)
```

#### 3.3 Step (é˜¶æ¢¯å¼)
```python
lr = lr_initial Ã— gamma^(epoch // step_size)
```

---

### 4. Metrics (è¯„ä¼°æŒ‡æ ‡)

**mAP å˜åŒ–æ›²çº¿**:
```python
# ç»˜åˆ¶ mAP æ›²çº¿
plt.figure(figsize=(10, 6))
plt.plot(results['epoch'], results['metrics/mAP50(B)'], label='mAP@0.5')
plt.plot(results['epoch'], results['metrics/mAP50-95(B)'], label='mAP@0.5:0.95')
plt.xlabel('Epoch')
plt.ylabel('mAP')
plt.title('mAP vs Epoch')
plt.legend()
plt.grid(True)
plt.savefig('map_curves.png')
```

---

## å®éªŒè®¾è®¡æŒ‡å—

### 1. åŸºå‡†å®éªŒè®¾ç½®

**ç›®çš„**: å»ºç«‹å¯å¤ç°çš„åŸºå‡†æ€§èƒ½

**æ ‡å‡†é…ç½®**:
```python
from ultralytics import YOLO

# è®­ç»ƒé…ç½®
model = YOLO('yolov8n.yaml')
results = model.train(
    data='coco.yaml',
    epochs=300,
    imgsz=640,
    batch=16,
    device=0,

    # ä¼˜åŒ–å™¨
    optimizer='AdamW',
    lr0=0.01,
    lrf=0.01,
    momentum=0.937,
    weight_decay=0.0005,

    # æ•°æ®å¢å¼º
    hsv_h=0.015,
    hsv_s=0.7,
    hsv_v=0.4,
    degrees=0.0,
    translate=0.1,
    scale=0.5,
    shear=0.0,
    perspective=0.0,
    flipud=0.0,
    fliplr=0.5,
    mosaic=1.0,
    mixup=0.0,

    # å…¶ä»–
    patience=50,
    save=True,
    save_period=-1,
    val=True,
    plots=True,
    verbose=True,
)

# éªŒè¯
val_results = model.val(data='coco.yaml')

# æ¨ç†é€Ÿåº¦æµ‹è¯•
import time
import numpy as np

latencies = []
for _ in range(100):
    start = time.time()
    results = model.predict('test.jpg', verbose=False)
    latencies.append((time.time() - start) * 1000)

print(f'Mean Latency: {np.mean(latencies):.2f} ms')
print(f'FPS: {1000 / np.mean(latencies):.2f}')
```

---

### 2. æ¶ˆèå®éªŒè®¾è®¡

**å®šä¹‰**: é€šè¿‡é€æ­¥ç§»é™¤æˆ–ä¿®æ”¹æ¨¡å‹ç»„ä»¶ï¼Œè¯„ä¼°å„ç»„ä»¶çš„è´¡çŒ®

#### 2.1 æ¨¡å—æ¶ˆè

**ç¤ºä¾‹**: è¯„ä¼°æ³¨æ„åŠ›æœºåˆ¶çš„ä½œç”¨

```python
# å®éªŒç»„
experiments = {
    'baseline': {
        'model': 'yolov8n.yaml',  # åŸå§‹æ¨¡å‹
        'description': 'åŸºå‡†æ¨¡å‹'
    },
    'with_cbam': {
        'model': 'yolov8n-cbam.yaml',  # æ·»åŠ  CBAM
        'description': 'æ·»åŠ  CBAM æ³¨æ„åŠ›'
    },
    'with_psa': {
        'model': 'yolov8n-psa.yaml',  # æ·»åŠ  PSA
        'description': 'æ·»åŠ  PSA æ³¨æ„åŠ›'
    },
}

# è¿è¡Œå®éªŒ
results = {}
for name, config in experiments.items():
    print(f"\n{'='*50}")
    print(f"Running: {config['description']}")
    print('='*50)

    model = YOLO(config['model'])
    train_results = model.train(
        data='coco.yaml',
        epochs=100,
        batch=16,
        name=name,
    )

    # è®°å½•ç»“æœ
    results[name] = {
        'mAP50': train_results.box.map50,
        'mAP': train_results.box.map,
        'params': sum(p.numel() for p in model.model.parameters()),
        'gflops': model.info()[1],
    }

# å¯¹æ¯”ç»“æœ
import pandas as pd
df = pd.DataFrame(results).T
print("\næ¶ˆèå®éªŒç»“æœ:")
print(df)
```

#### 2.2 è¶…å‚æ•°æ¶ˆè

**ç¤ºä¾‹**: è¯„ä¼°ä¸åŒå­¦ä¹ ç‡çš„å½±å“

```python
learning_rates = [0.001, 0.005, 0.01, 0.05, 0.1]

for lr in learning_rates:
    model = YOLO('yolov8n.yaml')
    model.train(
        data='coco.yaml',
        epochs=100,
        lr0=lr,
        name=f'lr_{lr}',
    )
```

---

### 3. å¯¹æ¯”å®éªŒè®¾è®¡

**ç›®çš„**: å¯¹æ¯”ä¸åŒæ¨¡å‹æˆ–æ–¹æ³•çš„æ€§èƒ½

**å®éªŒè®¾ç½®**:
```python
models = {
    'YOLOv8n': 'yolov8n.pt',
    'YOLOv8s': 'yolov8s.pt',
    'YOLOv8m': 'yolov8m.pt',
    'YOLOv5n': 'yolov5n.pt',
    'YOLOv5s': 'yolov5s.pt',
}

# ç»Ÿä¸€è¯„ä¼°
results = {}
for name, weights in models.items():
    model = YOLO(weights)

    # ç²¾åº¦è¯„ä¼°
    val_results = model.val(data='coco.yaml')

    # é€Ÿåº¦è¯„ä¼°
    latencies = []
    for _ in range(100):
        start = time.time()
        model.predict('test.jpg', verbose=False)
        latencies.append((time.time() - start) * 1000)

    # å¤æ‚åº¦è¯„ä¼°
    params = sum(p.numel() for p in model.model.parameters())

    results[name] = {
        'mAP50': val_results.box.map50,
        'mAP': val_results.box.map,
        'Params(M)': params / 1e6,
        'Latency(ms)': np.mean(latencies),
        'FPS': 1000 / np.mean(latencies),
    }

# å¯è§†åŒ–å¯¹æ¯”
df = pd.DataFrame(results).T
print(df)

# ç»˜åˆ¶æ•£ç‚¹å›¾: mAP vs FPS
plt.figure(figsize=(10, 6))
plt.scatter(df['FPS'], df['mAP'], s=df['Params(M)'] * 10, alpha=0.6)
for name in df.index:
    plt.annotate(name, (df.loc[name, 'FPS'], df.loc[name, 'mAP']))
plt.xlabel('FPS')
plt.ylabel('mAP@0.5:0.95')
plt.title('Model Performance Comparison')
plt.grid(True)
plt.savefig('model_comparison.png')
```

---

### 4. æ•°æ®é›†è§„æ¨¡å®éªŒ

**ç›®çš„**: è¯„ä¼°æ•°æ®é›†å¤§å°å¯¹æ€§èƒ½çš„å½±å“

```python
data_ratios = [0.1, 0.25, 0.5, 0.75, 1.0]

for ratio in data_ratios:
    # åˆ›å»ºå­æ•°æ®é›†
    create_subset_dataset('coco.yaml', ratio, f'coco_{int(ratio*100)}.yaml')

    # è®­ç»ƒ
    model = YOLO('yolov8n.yaml')
    model.train(
        data=f'coco_{int(ratio*100)}.yaml',
        epochs=100,
        name=f'data_{int(ratio*100)}',
    )
```

---

## æŒ‡æ ‡è®¡ç®—ä¸å¯è§†åŒ–

### 1. PR æ›²çº¿ (Precision-Recall Curve)

**å®šä¹‰**: å±•ç¤ºä¸åŒç½®ä¿¡åº¦é˜ˆå€¼ä¸‹ Precision å’Œ Recall çš„å…³ç³»

**ç»˜åˆ¶æ–¹æ³•**:
```python
import matplotlib.pyplot as plt
from ultralytics import YOLO

model = YOLO('yolov8n.pt')
results = model.val(data='coco.yaml')

# PR æ›²çº¿è‡ªåŠ¨ä¿å­˜åˆ° runs/detect/val/PR_curve.png
# ä¹Ÿå¯ä»¥æ‰‹åŠ¨ç»˜åˆ¶
for i, class_name in enumerate(model.names.values()):
    precision = results.box.p[i]
    recall = results.box.r[i]

    plt.plot(recall, precision, label=class_name)

plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title('Precision-Recall Curve')
plt.legend()
plt.grid(True)
plt.savefig('pr_curve.png')
```

---

### 2. F1-Confidence Curve

**å®šä¹‰**: å±•ç¤ºä¸åŒç½®ä¿¡åº¦é˜ˆå€¼ä¸‹çš„ F1 åˆ†æ•°

```python
confidences = np.linspace(0, 1, 100)
f1_scores = []

for conf in confidences:
    # ä½¿ç”¨ä¸åŒç½®ä¿¡åº¦é˜ˆå€¼é¢„æµ‹
    results = model.val(data='coco.yaml', conf=conf)
    precision = results.box.mp
    recall = results.box.mr
    f1 = 2 * (precision * recall) / (precision + recall + 1e-6)
    f1_scores.append(f1)

plt.plot(confidences, f1_scores)
plt.xlabel('Confidence Threshold')
plt.ylabel('F1-Score')
plt.title('F1-Confidence Curve')
plt.grid(True)
plt.savefig('f1_confidence.png')

# æ‰¾åˆ°æœ€ä½³ç½®ä¿¡åº¦é˜ˆå€¼
best_conf = confidences[np.argmax(f1_scores)]
print(f'Best Confidence Threshold: {best_conf:.3f}')
```

---

### 3. é€Ÿåº¦-ç²¾åº¦æƒè¡¡æ›²çº¿

**ç›®çš„**: å±•ç¤ºä¸åŒæ¨¡å‹åœ¨é€Ÿåº¦å’Œç²¾åº¦ä¹‹é—´çš„æƒè¡¡

```python
models = ['yolov8n', 'yolov8s', 'yolov8m', 'yolov8l', 'yolov8x']
mAPs = []
latencies = []

for model_name in models:
    model = YOLO(f'{model_name}.pt')

    # ç²¾åº¦
    val_results = model.val(data='coco.yaml')
    mAPs.append(val_results.box.map)

    # é€Ÿåº¦
    lats = []
    for _ in range(100):
        start = time.time()
        model.predict('test.jpg', verbose=False)
        lats.append((time.time() - start) * 1000)
    latencies.append(np.mean(lats))

# ç»˜åˆ¶
plt.figure(figsize=(10, 6))
plt.plot(latencies, mAPs, 'o-')
for i, name in enumerate(models):
    plt.annotate(name, (latencies[i], mAPs[i]))
plt.xlabel('Latency (ms)')
plt.ylabel('mAP@0.5:0.95')
plt.title('Speed-Accuracy Trade-off')
plt.grid(True)
plt.savefig('speed_accuracy_tradeoff.png')
```

---

### 4. æ··æ·†çŸ©é˜µå¯è§†åŒ–

```python
from ultralytics import YOLO

model = YOLO('yolov8n.pt')
results = model.val(data='coco.yaml', plots=True)

# æ··æ·†çŸ©é˜µè‡ªåŠ¨ä¿å­˜åˆ°:
# runs/detect/val/confusion_matrix.png
# runs/detect/val/confusion_matrix_normalized.png
```

---

## å¸¸è§é—®é¢˜ä¸æ³¨æ„äº‹é¡¹

### 1. æŒ‡æ ‡é€‰æ‹©æŒ‡å—

**é—®é¢˜**: åº”è¯¥å…³æ³¨å“ªäº›æŒ‡æ ‡ï¼Ÿ

**å›ç­”**: æ ¹æ®ç ”ç©¶ç›®æ ‡é€‰æ‹©

| ç ”ç©¶ç›®æ ‡ | æ ¸å¿ƒæŒ‡æ ‡ | æ¬¡è¦æŒ‡æ ‡ |
|---------|---------|---------|
| **é«˜ç²¾åº¦æ£€æµ‹** | mAP@0.5:0.95, AP_small | Precision, Recall |
| **å®æ—¶æ£€æµ‹** | FPS, Latency | mAP@0.5, Params |
| **è¾¹ç¼˜éƒ¨ç½²** | Model Size, FLOPs, FPS | mAP@0.5 |
| **æ¨¡å‹å‹ç¼©** | Params, FLOPs, Size | mAP ä¸‹é™å¹…åº¦ |
| **å°ç›®æ ‡æ£€æµ‹** | AP_small, Recall | mAP@0.5:0.95 |
| **å·¥ä¸šåº”ç”¨** | Precision, FPS | mAP@0.5, Latency |

---

### 2. å¸¸è§é”™è¯¯

#### é”™è¯¯ 1: ä¸å…¬å¹³å¯¹æ¯”

**é—®é¢˜**: ä½¿ç”¨ä¸åŒè®¾ç½®å¯¹æ¯”æ¨¡å‹
```python
# é”™è¯¯ç¤ºä¾‹
model1.val(imgsz=640)
model2.val(imgsz=1280)  # åˆ†è¾¨ç‡ä¸åŒï¼
```

**æ­£ç¡®åšæ³•**:
```python
# ç»Ÿä¸€è®¾ç½®
for model in models:
    model.val(
        data='coco.yaml',
        imgsz=640,          # ç»Ÿä¸€åˆ†è¾¨ç‡
        batch=32,           # ç»Ÿä¸€æ‰¹æ¬¡
        conf=0.001,         # ç»Ÿä¸€ç½®ä¿¡åº¦
        iou=0.6,            # ç»Ÿä¸€ NMS é˜ˆå€¼
    )
```

---

#### é”™è¯¯ 2: å¿½ç•¥é¢„çƒ­

**é—®é¢˜**: é¦–æ¬¡æ¨ç†é€Ÿåº¦æ…¢ï¼Œå½±å“æµ‹é€Ÿå‡†ç¡®æ€§

```python
# é”™è¯¯ç¤ºä¾‹
start = time.time()
for _ in range(100):
    model.predict('test.jpg')
fps = 100 / (time.time() - start)
```

**æ­£ç¡®åšæ³•**:
```python
# é¢„çƒ­
for _ in range(10):
    model.predict('test.jpg', verbose=False)

# æ­£å¼æµ‹é€Ÿ
start = time.time()
for _ in range(100):
    model.predict('test.jpg', verbose=False)
fps = 100 / (time.time() - start)
```

---

#### é”™è¯¯ 3: å•æ¬¡æµ‹é‡

**é—®é¢˜**: å•æ¬¡æµ‹é‡ä¸ç¨³å®š

**æ­£ç¡®åšæ³•**:
```python
# å¤šæ¬¡æµ‹é‡å–å¹³å‡
latencies = []
for _ in range(100):
    start = time.time()
    model.predict('test.jpg', verbose=False)
    latencies.append((time.time() - start) * 1000)

mean_latency = np.mean(latencies)
std_latency = np.std(latencies)
print(f'Latency: {mean_latency:.2f} Â± {std_latency:.2f} ms')
```

---

### 3. ç¡¬ä»¶å½±å“

**é—®é¢˜**: ä¸åŒç¡¬ä»¶æ€§èƒ½å·®å¼‚å¤§

**å»ºè®®**:
1. **æ˜ç¡®è¯´æ˜ç¡¬ä»¶é…ç½®**
   ```
   GPU: NVIDIA RTX 3080 (10GB)
   CPU: Intel i9-10900K
   RAM: 32GB DDR4
   CUDA: 11.8
   cuDNN: 8.6
   PyTorch: 2.0.0
   ```

2. **ä½¿ç”¨ç›¸å¯¹æŒ‡æ ‡**
   - åŠ é€Ÿæ¯”: Speedup = FPS_improved / FPS_baseline
   - mAP æå‡: Î”mAP = mAP_improved - mAP_baseline

3. **å¤šè®¾å¤‡éªŒè¯**
   - åœ¨å¤šä¸ªGPUä¸Šæµ‹è¯•
   - æä¾› CPU æ€§èƒ½æ•°æ®

---

### 4. æ•°æ®é›†å½±å“

**é—®é¢˜**: ä¸åŒæ•°æ®é›†ç»“æœä¸å¯æ¯”

**æ•°æ®é›†ç‰¹ç‚¹**:

| æ•°æ®é›† | å›¾åƒæ•° | ç±»åˆ«æ•° | éš¾åº¦ | ç‰¹ç‚¹ |
|-------|-------|-------|------|------|
| COCO | 118K train, 5K val | 80 | é«˜ | æ ‡å‡†åŸºå‡†ï¼Œå°ç›®æ ‡å¤š |
| VOC | 16K | 20 | ä¸­ | ç»å…¸æ•°æ®é›†ï¼Œç›®æ ‡è¾ƒå¤§ |
| Objects365 | 600K | 365 | é«˜ | å¤§è§„æ¨¡ï¼Œç±»åˆ«å¤š |
| LVIS | 100K | 1203 | å¾ˆé«˜ | é•¿å°¾åˆ†å¸ƒ |

**å»ºè®®**:
- ä½¿ç”¨æ ‡å‡†æ•°æ®é›† (COCO)
- æŠ¥å‘Šæ•°æ®é›†è¯¦ç»†ä¿¡æ¯
- æä¾›æ•°æ®é›†åˆ‡åˆ†ä¿¡æ¯

---

### 5. å¯å¤ç°æ€§æ£€æŸ¥æ¸…å•

**ä»£ç **:
- [ ] è®¾ç½®éšæœºç§å­
  ```python
  import random
  import numpy as np
  import torch

  def set_seed(seed=42):
      random.seed(seed)
      np.random.seed(seed)
      torch.manual_seed(seed)
      torch.cuda.manual_seed_all(seed)
      torch.backends.cudnn.deterministic = True

  set_seed(42)
  ```

- [ ] å›ºå®šæ•°æ®å¢å¼º
- [ ] è®°å½•æ‰€æœ‰è¶…å‚æ•°
- [ ] ä¿å­˜è®­ç»ƒæ—¥å¿—

**ç¡¬ä»¶**:
- [ ] è®°å½• GPU å‹å·
- [ ] è®°å½• CUDA ç‰ˆæœ¬
- [ ] è®°å½• PyTorch ç‰ˆæœ¬
- [ ] è®°å½•å†…å­˜å¤§å°

**æ•°æ®**:
- [ ] è®°å½•æ•°æ®é›†ç‰ˆæœ¬
- [ ] è®°å½•è®­ç»ƒ/éªŒè¯åˆ‡åˆ†
- [ ] è®°å½•æ•°æ®é¢„å¤„ç†æ–¹æ³•

---

## è®ºæ–‡å†™ä½œå»ºè®®

### 1. ç»“æœè¡¨æ ¼æ¨¡æ¿

**è¡¨1: ä¸åŒæ¨¡å‹åœ¨ COCO val2017 ä¸Šçš„æ€§èƒ½å¯¹æ¯”**

| Model | Params (M) | GFLOPs | mAP@0.5 | mAP@0.5:0.95 | AP_S | AP_M | AP_L | FPS (V100) |
|-------|-----------|--------|---------|--------------|------|------|------|-----------|
| YOLOv8n | 3.2 | 8.7 | 52.8 | 37.3 | 18.9 | 42.3 | 53.2 | 238 |
| YOLOv8s | 11.2 | 28.6 | 61.5 | 44.9 | 24.7 | 49.8 | 61.2 | 156 |
| Ours | **10.8** | **25.3** | **62.1** | **45.3** | **25.2** | **50.1** | **61.8** | **165** |

*æ³¨: ç²—ä½“è¡¨ç¤ºæœ€ä¼˜ç»“æœã€‚æµ‹è¯•ç¯å¢ƒ: NVIDIA V100, Batch=1, Input=640Ã—640*

---

### 2. æ¶ˆèå®éªŒè¡¨æ ¼

**è¡¨2: æ¶ˆèå®éªŒç»“æœ**

| Component | mAP@0.5:0.95 | Params (M) | GFLOPs | FPS |
|-----------|--------------|-----------|--------|-----|
| Baseline | 44.9 | 11.2 | 28.6 | 156 |
| + CBAM | 45.4 (+0.5) | 11.5 (+0.3) | 29.1 (+0.5) | 152 (-4) |
| + PSA | 45.7 (+0.8) | 11.8 (+0.6) | 30.2 (+1.6) | 148 (-8) |
| + Our Module | **46.2 (+1.3)** | **11.3 (+0.1)** | **28.8 (+0.2)** | **154 (-2)** |

---

### 3. å›¾è¡¨å»ºè®®

**æ¨èå›¾è¡¨**:
1. **é€Ÿåº¦-ç²¾åº¦æ›²çº¿**: å±•ç¤ºæ¨¡å‹åœ¨ä¸åŒé…ç½®ä¸‹çš„æƒè¡¡
2. **è®­ç»ƒæ›²çº¿**: Loss å’Œ mAP éš epoch å˜åŒ–
3. **PR æ›²çº¿**: å±•ç¤º Precision-Recall å…³ç³»
4. **å¯è§†åŒ–ç»“æœ**: å¯¹æ¯”ä¸åŒæ¨¡å‹çš„æ£€æµ‹ç»“æœ
5. **æ··æ·†çŸ©é˜µ**: å±•ç¤ºç±»åˆ«é—´çš„æ··æ·†æƒ…å†µ

---

### 4. å®éªŒæè¿°æ¨¡æ¿

**è®­ç»ƒç»†èŠ‚**:
```
æˆ‘ä»¬ä½¿ç”¨ YOLOv8n ä½œä¸ºåŸºå‡†æ¨¡å‹ï¼Œåœ¨ COCO train2017 ä¸Šè®­ç»ƒ 300 ä¸ª epochã€‚
é‡‡ç”¨ AdamW ä¼˜åŒ–å™¨ï¼Œåˆå§‹å­¦ä¹ ç‡ä¸º 0.01ï¼Œä½¿ç”¨ä½™å¼¦é€€ç«ç­–ç•¥è¡°å‡è‡³ 0.0001ã€‚
æ‰¹æ¬¡å¤§å°è®¾ä¸º 16ï¼Œè¾“å…¥åˆ†è¾¨ç‡ä¸º 640Ã—640ã€‚æ•°æ®å¢å¼ºåŒ…æ‹¬éšæœºæ°´å¹³ç¿»è½¬ã€
HSV é¢œè‰²ç©ºé—´æŠ–åŠ¨å’Œ Mosaic å¢å¼ºã€‚æ‰€æœ‰å®éªŒåœ¨å•å— NVIDIA RTX 3080 GPU
ä¸Šè¿›è¡Œï¼Œä½¿ç”¨ PyTorch 2.0.0 å’Œ CUDA 11.8ã€‚
```

**è¯„ä¼°ç»†èŠ‚**:
```
æˆ‘ä»¬åœ¨ COCO val2017 ä¸Šè¯„ä¼°æ¨¡å‹æ€§èƒ½ï¼Œä½¿ç”¨å®˜æ–¹è¯„ä¼°è„šæœ¬è®¡ç®— mAP@0.5 å’Œ
mAP@0.5:0.95ã€‚æ¨ç†é€Ÿåº¦åœ¨ NVIDIA V100 GPU ä¸Šæµ‹é‡ï¼Œæ‰¹æ¬¡å¤§å°ä¸º 1ï¼Œ
è¾“å…¥åˆ†è¾¨ç‡ä¸º 640Ã—640ã€‚æ¯ä¸ªæ¨¡å‹æµ‹è¯• 100 æ¬¡å–å¹³å‡å€¼ï¼Œå¹¶æŠ¥å‘Šæ ‡å‡†å·®ã€‚
```

---

## æ€»ç»“

### æ ¸å¿ƒæŒ‡æ ‡ä¼˜å…ˆçº§

**ç ”ç©¶è®ºæ–‡å¿…é¡»æŠ¥å‘Š**:
1. âœ… mAP@0.5:0.95
2. âœ… mAP@0.5
3. âœ… Parameters
4. âœ… FLOPs/GFLOPs
5. âœ… FPS æˆ– Latency

**å»ºè®®æŠ¥å‘Š**:
6. â­ AP_small, AP_medium, AP_large
7. â­ Precision å’Œ Recall
8. â­ Model Size
9. â­ è®­ç»ƒæ—¶é—´

**å¯é€‰æŠ¥å‘Š**:
10. ğŸ’¡ F1-Score
11. ğŸ’¡ æ··æ·†çŸ©é˜µ
12. ğŸ’¡ æ¶ˆèå®éªŒç»†èŠ‚

---

### å¿«é€ŸæŒ‡æ ‡è·å–ä»£ç 

```python
from ultralytics import YOLO
import time
import numpy as np
import torch

def comprehensive_evaluation(model_path, data='coco.yaml', device=0):
    """
    å…¨é¢è¯„ä¼°æ¨¡å‹æ€§èƒ½

    è¿”å›:
        dict: åŒ…å«æ‰€æœ‰å…³é”®æŒ‡æ ‡çš„å­—å…¸
    """
    model = YOLO(model_path)

    # 1. ç²¾åº¦è¯„ä¼°
    print("Evaluating accuracy...")
    val_results = model.val(data=data, device=device)

    # 2. é€Ÿåº¦è¯„ä¼°
    print("Evaluating speed...")
    model.to(f'cuda:{device}')

    # é¢„çƒ­
    for _ in range(10):
        model.predict('test.jpg', verbose=False, device=device)

    # æµ‹é€Ÿ
    latencies = []
    for _ in range(100):
        start = time.time()
        model.predict('test.jpg', verbose=False, device=device)
        latencies.append((time.time() - start) * 1000)

    # 3. å¤æ‚åº¦è¯„ä¼°
    print("Evaluating complexity...")
    params = sum(p.numel() for p in model.model.parameters())

    # 4. å†…å­˜è¯„ä¼°
    torch.cuda.empty_cache()
    torch.cuda.reset_peak_memory_stats()
    model.predict('test.jpg', verbose=False, device=device)
    memory_mb = torch.cuda.max_memory_allocated() / 1024**2

    # æ±‡æ€»ç»“æœ
    results = {
        # ç²¾åº¦æŒ‡æ ‡
        'mAP@0.5': val_results.box.map50,
        'mAP@0.5:0.95': val_results.box.map,
        'AP_small': val_results.box.maps[0],
        'AP_medium': val_results.box.maps[1],
        'AP_large': val_results.box.maps[2],
        'Precision': val_results.box.mp,
        'Recall': val_results.box.mr,

        # å¤æ‚åº¦æŒ‡æ ‡
        'Parameters(M)': params / 1e6,
        'Model_Size(MB)': os.path.getsize(model_path) / 1024**2,

        # é€Ÿåº¦æŒ‡æ ‡
        'Mean_Latency(ms)': np.mean(latencies),
        'Std_Latency(ms)': np.std(latencies),
        'P95_Latency(ms)': np.percentile(latencies, 95),
        'FPS': 1000 / np.mean(latencies),

        # å†…å­˜æŒ‡æ ‡
        'GPU_Memory(MB)': memory_mb,
    }

    return results

# ä½¿ç”¨ç¤ºä¾‹
results = comprehensive_evaluation('yolov8n.pt', data='coco.yaml', device=0)

# æ‰“å°ç»“æœ
print("\n" + "="*60)
print("COMPREHENSIVE EVALUATION RESULTS")
print("="*60)
for key, value in results.items():
    print(f"{key:.<40} {value:.3f}")
print("="*60)

# ä¿å­˜åˆ° CSV
import pandas as pd
df = pd.DataFrame([results])
df.to_csv('evaluation_results.csv', index=False)
print("\nResults saved to evaluation_results.csv")
```

---

**å‚è€ƒæ–‡çŒ®**:
1. Lin et al. "Microsoft COCO: Common Objects in Context" ECCV 2014
2. Redmon et al. "You Only Look Once: Unified, Real-Time Object Detection" CVPR 2016
3. Zheng et al. "Distance-IoU Loss: Faster and Better Learning for Bounding Box Regression" AAAI 2020

---

**æ›´æ–°æ—¥æœŸ**: 2026-01-08
**é€‚ç”¨ç‰ˆæœ¬**: Ultralytics YOLOv8, YOLOv9, YOLOv10
